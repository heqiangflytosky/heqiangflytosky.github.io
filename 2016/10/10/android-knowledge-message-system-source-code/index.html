<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android 消息机制," />





  <link rel="alternate" href="/atom.xml" title="孤舟蓑笠翁，独钓寒江雪" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0" />






<meta name="description" content="本文介绍 Android 消息机制，并分析卡顿监测工具BlockCanary的实现原理">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 消息机制 -- 源码分析">
<meta property="og:url" content="http://yoursite.com/2016/10/10/android-knowledge-message-system-source-code/index.html">
<meta property="og:site_name" content="孤舟蓑笠翁，独钓寒江雪">
<meta property="og:description" content="本文介绍 Android 消息机制，并分析卡顿监测工具BlockCanary的实现原理">
<meta property="og:image" content="http://www.plantuml.com/plantuml/svg/VP2zIWD1483xUOeXLKJo1XQnKr1GIISMUtV3ShW_nyvk8OS1kxo3leFOf53mRNA-XcFSFQEYrGpVV3i_E-UeGapMmAADXd1ow9hWsmQ7zMguUnmUdZUhzTlJo-R-TG9G6yMCHyerXWBsiCGJxpj9xMSKS4hCIjDveaHejm7sqLTHjIxNfdj2EiznUf6SKvMC3H-8oJL5oH4jwtzBjsMfGdkn9PS7cW86wipDmiDoN5hErHG5ZBDhPKobwkiVlSeDFSpmM9xc1fTNQCzaczRf7SfVbwFD2SFOiNnJ_yS7YGTPEPZDogwmgtuhvBXbMVebvvc5ZsvnO2vN96lU0G00">
<meta property="og:updated_time" content="2019-11-12T01:14:15.656Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android 消息机制 -- 源码分析">
<meta name="twitter:description" content="本文介绍 Android 消息机制，并分析卡顿监测工具BlockCanary的实现原理">
<meta name="twitter:image" content="http://www.plantuml.com/plantuml/svg/VP2zIWD1483xUOeXLKJo1XQnKr1GIISMUtV3ShW_nyvk8OS1kxo3leFOf53mRNA-XcFSFQEYrGpVV3i_E-UeGapMmAADXd1ow9hWsmQ7zMguUnmUdZUhzTlJo-R-TG9G6yMCHyerXWBsiCGJxpj9xMSKS4hCIjDveaHejm7sqLTHjIxNfdj2EiznUf6SKvMC3H-8oJL5oH4jwtzBjsMfGdkn9PS7cW86wipDmiDoN5hErHG5ZBDhPKobwkiVlSeDFSpmM9xc1fTNQCzaczRf7SfVbwFD2SFOiNnJ_yS7YGTPEPZDogwmgtuhvBXbMVebvvc5ZsvnO2vN96lU0G00">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6377131610457769000',
      author: '寒江蓑笠'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/10/10/android-knowledge-message-system-source-code/"/>





  <title> Android 消息机制 -- 源码分析 | 孤舟蓑笠翁，独钓寒江雪 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1261134288&web_id=1261134288" language="JavaScript"></script>
  </div>





  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">孤舟蓑笠翁，独钓寒江雪</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">程序猿的世界</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-links">
          <a href="/links" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-users"></i> <br />
            
            友情链接
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/10/android-knowledge-message-system-source-code/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="寒江蓑笠">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/icon.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="孤舟蓑笠翁，独钓寒江雪">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="孤舟蓑笠翁，独钓寒江雪" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android 消息机制 -- 源码分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-10-10T10:00:00+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-消息机制/" itemprop="url" rel="index">
                    <span itemprop="name">Android 消息机制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2016/10/10/android-knowledge-message-system-source-code/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/10/10/android-knowledge-message-system-source-code/" class="leancloud_visitors" data-flag-title="Android 消息机制 -- 源码分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
              <div class="post-description">
                  本文介绍 Android 消息机制，并分析卡顿监测工具BlockCanary的实现原理
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文介绍的消息机制主要指消息在进程内的传递机制，Android 内的消息传递无处不在，主要涉及到下面的四个类：</p>
<ul>
<li>Handler：用于发送消息 <code>Handler.sendMessage</code> 和处理消息 <code>Handler.handleMessage</code> 的类。</li>
<li>Message：用于传输的消息体的类。</li>
<li>MessageQueue：消息队列，主要用来存放消息 <code>MessageQueue.enqueueMessage</code> 和发出消息 <code>MessageQueue.next()</code> 。<code>MessageQueue</code> 是一个单向链表，<code>Message</code> 对象有个 <code>next</code> 变量保存列表中的下一个，<code>MessageQueue</code> 中的 <code>mMessages</code> 保存链表的第一个元素。</li>
<li>Looper：不断循环执行 <code>Looper.loop</code>，按分发机制将消息分发给目标处理者。</li>
</ul>
<p>Handler 是我们在 Android 线程间通信的主要手段。<br>看一下它们之间的关系图：</p>
<p><img src="http://www.plantuml.com/plantuml/svg/VP2zIWD1483xUOeXLKJo1XQnKr1GIISMUtV3ShW_nyvk8OS1kxo3leFOf53mRNA-XcFSFQEYrGpVV3i_E-UeGapMmAADXd1ow9hWsmQ7zMguUnmUdZUhzTlJo-R-TG9G6yMCHyerXWBsiCGJxpj9xMSKS4hCIjDveaHejm7sqLTHjIxNfdj2EiznUf6SKvMC3H-8oJL5oH4jwtzBjsMfGdkn9PS7cW86wipDmiDoN5hErHG5ZBDhPKobwkiVlSeDFSpmM9xc1fTNQCzaczRf7SfVbwFD2SFOiNnJ_yS7YGTPEPZDogwmgtuhvBXbMVebvvc5ZsvnO2vN96lU0G00" alt="效果图"></p>
<!-- 
@startuml
Title "Android 消息机制类图"

class Handler {
~ Looper mLooper
~ MessageQueue mQueue
+ obtainMessage()
+ post(Runnable r)
+ sendMessage(Message msg)
+ sendMessage(Message msg)
}

class Message {
+ Messenger replyTo
~ Handler target
~ Runnable callback
}

class MessageQueue {
- IdleHandler[] mPendingIdleHandlers
~ Message mMessages

}
-->
<p>在进行消息处理的代码编写中，我们是直接和 Handler 和 Message 打交道的。</p>
<ol>
<li>首先我们需要创建一个 Handler，Handler 内部持有 Looper 和 MessageQueue 对象，我们可以在创建 Handler 时为其指定 Looper，也可以不指定。如果指定了，后面的消息执行就在该 Looper 中执行，如果不指定，就会与Handler 创建时所在的线程的 Looper 指定。<code>mainHandler = new Handler()</code> 等价于 <code>new Handler(Looper.myLooper())</code>， <code>Looper.myLooper()</code> 用来获取当前进程的 Looper 对象。还有一个类似的 <code>Looper.getMainLooper()</code> 用于获取主线程的 Looper 对象。</li>
<li>Looper 类别用来为一个线程开启一个消息循环。默认情况下 Android 中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建 Looper 对象，开启消息循环）。<br>在非主线程中直接 new Handler() 会报如下的错误:<code>java.lang.RuntimeException: Can&#39;t create handler inside thread that has not called Looper.prepare()</code>，原因是非主线程中默认没有创建 Looper 对象，需要先调用 Looper.prepare() 启用 Looper。<br>需要先调用 Looper.prepare() 启用 Looper。<br>调用 Looper.loop() 让 Looper 开始工作，从消息队列里取消息，处理消息。<br><strong>注意</strong>：写在 Looper.loop() 之后的代码不会被执行，这个函数内部应该是一个循环，当调用 mHandler.getLooper().quit() 后，loop 才会中止，其后的代码才能得以运行。<br>Looper 对象通过 MessageQueue 来存放消息和事件。一个线程只能有一个 Looper，对应一个 MessageQueue。<br>通常是通过 Handler 对象来与 Looper 交互的。Handler 可看做是 Looper 的一个接口，用来向指定的 Looper 发送消息及定义处理方法。</li>
<li>Handler 和 Looper 准备好以后，就可以准备消息进行发送了，然后Handler接收到消息以后进行消息的响应和处理。可以参考下面的对应章节。</li>
</ol>
<p>分析过了源码，相信大家会对消息机制有更好的领悟，那么使用起来也就更加的得心应手。</p>
<h2 id="创建-Handler"><a href="#创建-Handler" class="headerlink" title="创建 Handler"></a>创建 Handler</h2><p><code>Handler</code> 一共有7个构造方法：</p>
<ul>
<li>Handler()</li>
<li>Handler(Callback callback)</li>
<li>Handler(Looper looper)</li>
<li>Handler(Looper looper, Callback callback)</li>
<li>Handler(boolean async)</li>
<li>Handler(Callback callback, boolean async)</li>
<li>Handler(Looper looper, Callback callback, boolean async)</li>
</ul>
<p>下面对这些参数做一下讲解</p>
<p>前面5个构造方法最终调用最后两个构造方法其中一个来完成初始化工作。<br>下面来分析一下这两个构造方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        // 这里如果打开了FIND_POTENTIAL_LEAKS开关</div><div class="line">        // 会判断是否是非静态的匿名内部类、非静态成员内部类或非静态局部内部类</div><div class="line">        // 如果是的话就给出警告</div><div class="line">        // 够体贴了吧？</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 这个构造函数没有指定 Looper 对象，就获取当前线程的 Looper 对象</div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    // 从Looper对象中获取消息队列</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    // 设置 handler 的 callback</div><div class="line">    mCallback = callback;</div><div class="line">    // 异步消息，后面详细介绍</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里我们可以看出，如果没有为 <code>Handler</code> 指定 <code>Looper</code>，那么就会获取当前创建 <code>Handler</code> 的 <code>Looper</code> 对象，那么后面对消息的处理也就在这个线程来处理了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public Handler(Looper looper, Callback callback, boolean async) &#123;</div><div class="line">    mLooper = looper;//设置Looper</div><div class="line">    mQueue = looper.mQueue;// 从Looper对象中获取消息队列</div><div class="line">    mCallback = callback;// 设置 handler 的 callback</div><div class="line">    mAsynchronous = async;// 异步消息，后面详细介绍</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个构造方法和前面一个不一样的地方就在于指定了 <code>Looper</code> 对象，那么后面对消息的处理也就在该 <code>Looper</code> 对应的线程来处理了。</p>
<h2 id="创建消息"><a href="#创建消息" class="headerlink" title="创建消息"></a>创建消息</h2><p>创建消息一般用下的方法：</p>
<ul>
<li>new Message</li>
<li>Handler.obtainMessage()</li>
<li>Handler.obtainMessage(int what)</li>
<li>Handler.obtainMessage(int what, Object obj)</li>
<li>Handler.obtainMessage(int what, int arg1, int arg2)</li>
<li>Handler.obtainMessage(int what, int arg1, int arg2, Object obj)</li>
<li>Message.obtain()</li>
<li>Message.obtain(Message orig)</li>
<li>Message.obtain(Handler h)</li>
<li>Message.obtain(Handler h, Runnable callback)</li>
<li>Message.obtain(Handler h, int what)</li>
<li>Message.obtain(Handler h, int what, Object obj)</li>
<li>Message.obtain(Handler h, int what, int arg1, int arg2)</li>
<li>Message.obtain(Handler h, int what, int arg1, int arg2, Object obj)</li>
</ul>
<p><code>new Message</code> 这种方式没什么需要解释的，直接调用相关构造函数创建一个 <code>Message</code> 实例出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Message message = new Message();</div><div class="line">message.what = result;</div><div class="line">message.obj = obj;</div><div class="line">sendMessage(message);</div></pre></td></tr></table></figure>
<p>再来看一下 <code>obtainMessage</code> 方法：<br>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obtainMessage(result, obj).sendToTarget();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final Message obtainMessage(int what, int arg1, int arg2, Object obj)</div><div class="line">&#123;</div><div class="line">    return Message.obtain(this, what, arg1, arg2, obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>obtainMessage</code> 的几个相关方法都调用了 <code>Message.obtain</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static Message obtain(Handler h, int what, int arg1, int arg2) &#123;</div><div class="line">    Message m = obtain();</div><div class="line">    m.target = h;</div><div class="line">    m.what = what;</div><div class="line">    m.arg1 = arg1;</div><div class="line">    m.arg2 = arg2;</div><div class="line"></div><div class="line">    return m;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static Message obtain() &#123;</div><div class="line">    synchronized (sPoolSync) &#123;</div><div class="line">        if (sPool != null) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = null;</div><div class="line">            m.flags = 0; // clear in-use flag</div><div class="line">            sPoolSize--;</div><div class="line">            return m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return new Message();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>obtainMessage</code> 是从整个 <code>Messge</code> 池中返回一个新的 <code>Message</code> 实例，通过 <code>obtainMessage</code> 能避免重复 <code>Message</code> 创建对象，比 <code>new Message</code> 效率更高。<br>从上面代码可以看到 <code>Handler.obtainMessage</code> 内部还是调用 <code>Message.obtain</code> 来实现的，没什么本质的区别。<br>不管上面以哪种方式创建 Message ，都要为其设定 target，也就是处理该 Message 的Handler，从而与 Handler 发生绑定。</p>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>可以使用下面的方法来发送消息：</p>
<ul>
<li>Handler.sendMessage(Message msg)</li>
<li>Handler.sendMessageDelayed(Message msg, long delayMillis)</li>
<li>Handler.sendMessageAtTime(Message msg, long uptimeMillis)</li>
<li>Handler.sendMessageAtFrontOfQueue(Message msg)</li>
<li>Handler.sendEmptyMessage(int what)</li>
<li>Handler.sendEmptyMessageDelayed(int what, long delayMillis)</li>
<li>Handler.sendEmptyMessageAtTime(int what, long uptimeMillis)</li>
<li>Handler.post(Runnable r)</li>
<li>Handler.postAtTime(Runnable r, long uptimeMillis)</li>
<li>Handler.postAtTime(Runnable r, Object token, long uptimeMillis)</li>
<li>Handler.postDelayed(Runnable r, long delayMillis)</li>
<li>Handler.postAtFrontOfQueue(Runnable r)</li>
<li>Message.sendToTarget()</li>
</ul>
<p>我们可以把它们归结为三种方法：<code>sendMessage</code>、<code>sendEmptyMessage</code>、<code>Handler.post</code> 和 <code>Message.sendToTarget()</code>。<br>先来看一下 <code>sendMessage</code> 相关的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码比较简单，把 <code>Message</code> 对象放到消息队列中去，等待执行。<br>再来看一下 <code>sendEmptyMessage</code> 相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123;</div><div class="line">    Message msg = Message.obtain();</div><div class="line">    msg.what = what;</div><div class="line">    return sendMessageDelayed(msg, delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>sendEmptyMessage</code> 最终是调用了 <code>sendMessage</code> 相关方法，<code>Message</code> 是通过 <code>Message.obtain()</code>，只设置了 <code>what</code> 属性。<br>再来看一下 <code>Handler.post</code> 相关方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final boolean post(Runnable r)</div><div class="line">&#123;</div><div class="line">   return  sendMessageDelayed(getPostMessage(r), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法最终调用的还是 <code>Handler.sendMessage</code> 的相关方法，知识这里要关注一下 <code>Handler.getPostMessage</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static Message getPostMessage(Runnable r, Object token) &#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.obj = token;</div><div class="line">    m.callback = r;</div><div class="line">    return m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样也是通过 <code>Message.obtain()</code> 获取 <code>Message</code> 对象，并把参数 <code>Runnable</code> 作为 <code>Message</code> 的回调方法，该回调的执行后面会介绍，是优先级最高的。<br>再来看一下 <code>Message.sendToTarget()</code> 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void sendToTarget() &#123;</div><div class="line">    target.sendMessage(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实还是调用 <code>Handler.sendMessage</code> 来完成 <code>Message</code> 的发送。</p>
<h2 id="消息队列-MessageQueue"><a href="#消息队列-MessageQueue" class="headerlink" title="消息队列 MessageQueue"></a>消息队列 MessageQueue</h2><p><code>MessageQueue</code> 的实例化实在 Looper 构造方法中进行的。<br>上面介绍到消息的发送，其实最终都是通过 <code>MessageQueue.enqueueMessage</code> 来将消息放入消息队列，然后等待消息的分发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">    // 一个 message 必须有 target（Handler），否则为无效消息</div><div class="line">    if (msg.target == null) &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">    &#125;</div><div class="line">    // 如果该消息正在使用，则抛出异常</div><div class="line">    if (msg.isInUse()) &#123;</div><div class="line">        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">        //正在退出时，回收msg，加入到消息池</div><div class="line">        if (mQuitting) &#123;</div><div class="line">            IllegalStateException e = new IllegalStateException(</div><div class="line">                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        // 标记该消息正在使用   </div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        boolean needWake;</div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">            // p 为null（队列中没有消息）或者消息执行时间是最早的，就把该消息作为队列的头部</div><div class="line">            // 如果队列再阻塞状态，则唤醒队列</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 将消息按照执行时间顺序插入到消息队列中去</div><div class="line">            // 如果在消息头部是 barrier （p.target == null）或者该消息是执行时间最早的异步消息</div><div class="line">            // 那么就唤醒消息队列</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            for (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                if (p == null || when &lt; p.when) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                // 如果不是消息头部的异步消息，不唤醒队列</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; // invariant: p == prev.next</div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">        if (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>消息的提取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">    // ptr == 0 表明当前队列已经销毁</div><div class="line">    final long ptr = mPtr;</div><div class="line">    if (ptr == 0) &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">    int nextPollTimeoutMillis = 0;</div><div class="line">    for (;;) &#123;</div><div class="line">        if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line">        // 调用native方法来阻塞nextPollTimeoutMillis秒的时间</div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            // Try to retrieve the next message.  Return if found.</div><div class="line">            final long now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = null;</div><div class="line">            Message msg = mMessages;</div><div class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                // 如果当前消息是 SyncBarrier，那么找到下一个异步消息，</div><div class="line">                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            if (msg != null) &#123;</div><div class="line">                // 通过前面的一步找到了消息</div><div class="line">                if (now &lt; msg.when) &#123;</div><div class="line">                    // 该消息还没有到达执行时间，则设置下一次轮询的超时时长</div><div class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // 如果到了执行时间，就取出这条消息返回</div><div class="line">                    mBlocked = false;</div><div class="line">                    if (prevMsg != null) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = null;</div><div class="line">                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                    msg.markInUse();</div><div class="line">                    return msg;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 通过前面的一步没有找到消息，说明消息队列已经空了</div><div class="line">                // 先设置为-1,如果后面的没有可以执行的 IdleHandler，那么就一直阻塞下去</div><div class="line">                // 直到有新的消息被唤醒</div><div class="line">                // 如果后面有 可以执行的 IdleHandler，nextPollTimeoutMillis被赋值为 0</div><div class="line">                nextPollTimeoutMillis = -1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 消息队列正在退出时返回null</div><div class="line">            if (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                return null;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 如果是第一次循环进入空闲时间，那么 pendingIdleHandlerCount 是为-1的，</div><div class="line">            // 这个时候获取一下当前 IdleHandler 的个数</div><div class="line">            // 只有当消息队列么有消息时或者是队列中的消息还有到执行时间是才会执行 IdleHandler</div><div class="line">            if (pendingIdleHandlerCount &lt; 0</div><div class="line">                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">            &#125;</div><div class="line">            if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">                // 如果没有 IdleHandler 需要执行，那么就等待下一个消息到来</div><div class="line">                mBlocked = true;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (mPendingIdleHandlers == null) &#123;</div><div class="line">                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class="line">            &#125;</div><div class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 当有idle handlers时，运行 idle handlers</div><div class="line">        // 执行一次next方法只有第一次轮询能执行这里的操作</div><div class="line">        // 执行后 pendingIdleHandlerCount 会被设置为0</div><div class="line">        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">            final IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">            mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class="line"></div><div class="line">            boolean keep = false;</div><div class="line">            try &#123;</div><div class="line">                // 执行 IdleHandler</div><div class="line">                keep = idler.queueIdle();</div><div class="line">            &#125; catch (Throwable t) &#123;</div><div class="line">                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (!keep) &#123;</div><div class="line">                // 如果不需要保留，那么移除这个 IdleHandler</div><div class="line">                synchronized (this) &#123;</div><div class="line">                    mIdleHandlers.remove(idler);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 设置 pendingIdleHandlerCount 0 保证在再次执行next方法之前不会再执行idle handler</div><div class="line">        pendingIdleHandlerCount = 0;</div><div class="line"></div><div class="line">        // 当调用一个空闲IdleHandler时，相当于分发了一个新message，因此无需等待可以直接查询pending message.</div><div class="line">        nextPollTimeoutMillis = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code> 方法，这里做一下介绍。<br>循环体内首先调用 <code>nativePollOnce(ptr, nextPollTimeoutMillis)</code>，这是一个Native方法，实际作用就是通过Native层的 <code>MessageQueue</code> 阻塞 <code>nextPollTimeoutMillis</code> 毫秒的时间。</p>
<ul>
<li>如果nextPollTimeoutMillis=-1，一直阻塞不会超时。</li>
<li>如果nextPollTimeoutMillis=0，不会阻塞，立即返回。</li>
<li>如果nextPollTimeoutMillis&gt;0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。</li>
</ul>
<h2 id="同步消息、异步消息和同步栅栏"><a href="#同步消息、异步消息和同步栅栏" class="headerlink" title="同步消息、异步消息和同步栅栏"></a>同步消息、异步消息和同步栅栏</h2><p>我们在构造 <code>Handler</code> 时有个参数是给变量 <code>mAsynchronous</code> 赋值，那这个变量代表什么意义呢？<br>在<code>Handler.enqueueMessage</code> 中通过 <code>Message.setAsynchronous</code> 来设置 <code>flags</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    ...</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况下如果我们不去设置 <code>Message.setAsynchronous</code> 都是同步消息，那么同步消息和异步消息有什么区别呢？<br>接下来我们就要看一下哪些地方有调用 <code>Message.isAsynchronous</code> 方法。<br>一个是在 <code>MessageQueue.enqueueMessage</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">            ......</div><div class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">            ......</div><div class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = false;</div><div class="line">                &#125;</div><div class="line">            ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一个是在 <code>MessageQueue.next</code> 方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">            ......</div><div class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用 <code>Message.isAsynchronous</code> 方法的地方都和 <code>msg.target == null</code> 有关，我们都知道，一般情况下 <code>Message</code> 的属性 <code>target</code> 是不能为空的，但有一种消息是例外的，就是 SyncBarrier，我们暂且管它叫同步栅栏。<br>SyncBarrier 是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中分发消息并进行处理时，一旦遇到这种 SyncBarrier，那么即使在 SyncBarrier 之后还有若干已经到时的同步 <code>Message</code>，也不会分发这些消息了。请注意，此时只是不会分发同步 <code>Message</code>，如果队列中还有异步 <code>Message</code>，那么还是会分发已到时的异步 <code>Message</code> 的。<br>如果消息队列中根本没有设置 SyncBarrier 的话，那么同步 <code>Message</code> 和异步 <code>Message</code> 的处理就没什么大的不同了。<br>那么如果设置 SyncBarrier 呢？<br>可以通过 <code>MessageQueue.postSyncBarrier</code> 方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">private int postSyncBarrier(long when) &#123;</div><div class="line">    // Enqueue a new sync barrier token.</div><div class="line">    // We don&apos;t need to wake the queue because the purpose of a barrier is to stall it.</div><div class="line">    synchronized (this) &#123;</div><div class="line">        final int token = mNextBarrierToken++;</div><div class="line">        final Message msg = Message.obtain();</div><div class="line">        msg.markInUse();</div><div class="line">        msg.when = when;</div><div class="line">        msg.arg1 = token;</div><div class="line"></div><div class="line">        Message prev = null;</div><div class="line">        Message p = mMessages;</div><div class="line">        if (when != 0) &#123;</div><div class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (prev != null) &#123; // invariant: p == prev.next</div><div class="line">            msg.next = p;</div><div class="line">            prev.next = msg;</div><div class="line">        &#125; else &#123;</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">        &#125;</div><div class="line">        return token;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，SyncBarrier 也是可以清除的，通过 <code>MessageQueue.removeSyncBarrier</code> 来实现。</p>
<h2 id="消息循环-Looper"><a href="#消息循环-Looper" class="headerlink" title="消息循环 Looper"></a>消息循环 Looper</h2><p>说到消息循环就和 <code>Looper</code> 相关了，在 <code>Looper</code> 中创建了一个 <code>MessageQueue</code> 对象，并通过 <code>loop</code> 方法不断的从当前线程的 <code>MessageQueue</code> 中取消息数据，调用该消息的 <code>Handler</code> 对象 <code>target</code> 的 <code>dispatchMessage()</code> 方法来分发消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">    final Looper me = myLooper();//获取ThreadLocal的Looper对象</div><div class="line">    if (me == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line">    // 进入循环</div><div class="line">    for (;;) &#123;</div><div class="line">        Message msg = queue.next(); // 获取消息队列中的消息，可能会阻塞</div><div class="line">        if (msg == null) &#123;</div><div class="line">            // 如果没有消息，说明消息队列已经退出</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // This must be in a local variable, in case a UI event sets the logger</div><div class="line">        // 打印开始分发消息 Log，可以通过 Looper.getMainLooper().setMessageLogging(printer) 为主线程设置 printer，</div><div class="line">        // 那么每次主线程处理消息都会触发开始和结束的打印，可以通过这个办法来监测系统的卡顿问题，</div><div class="line">        // 著名的卡顿监测框架BlockCanary就是用的这个原理</div><div class="line">        final Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final long traceTag = me.mTraceTag;</div><div class="line">        if (traceTag != 0) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            // 分发消息</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (traceTag != 0) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 打印分发结束的 Log</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ......</div><div class="line">        //将Message放入消息池</div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="消息分发和执行"><a href="#消息分发和执行" class="headerlink" title="消息分发和执行"></a>消息分发和执行</h2><p>消息的分发和执行都是由 Handler 来进行的。<br>来看一下 <code>Handler.dispatchMessage</code> 源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>当 <code>Message</code> 的回调方法不为空的时候，优先执行该回调方法来响应消息。这种情况是 <code>Message</code> 设置了 callback 时的情况，对应的 <code>Handler.post(Runnable r)</code> 这类发送消息的方法，这是就直接执行 post 的 <code>Runnable</code> 方法。</li>
<li>如果没有设置 <code>Message</code> 的回调方法，再看来 <code>Handler</code> 有没有设置 <code>Callback</code>，如果设置就执行该回调的 <code>handleMessage</code> 方法。对应的 <code>Handler(Callback callback)</code> 构造方法，这是直接执行 <code>Callback.handleMessage</code>。</li>
<li>如果上面两个回调方法都没有设置，那么就执行 <code>Handler.handleMessage</code> 方法。该方法默认为空实现，<code>Handler</code> 子类通过 override 该方法来完成具体的实现逻辑。</li>
</ol>
<p>消息队列中的消息都是同步执行的，一个任务执行完才会去消息队列中获取下一个消息进行执行。</p>
<h2 id="关于内存泄漏"><a href="#关于内存泄漏" class="headerlink" title="关于内存泄漏"></a>关于内存泄漏</h2><p>我们知道，Handler 使用不当会很容易造成内存泄漏，一般原因就是 Handler 的生命周期与 Activity 不一致，handler 引用 Activity 阻止了 GC 对 Acivity 的回收。<br>比如，Handler 以非静态(匿名)内部类的形式存在于 Activity 中，则该 Handler 会持有外部类 Activity 的引用。<br>我们知道，Message 一旦创建，就会与target Handler 发送绑定，持有 Handler 的引用，如果该 Message 未被处理，那么就会被 MessageQueue 一直持有，从而导致 Hander 对象也被 MessageQueue 持有，那么 Activity 也会被 MessageQueue 持有，如果 Activity 对象如果此时声明周期结束，则 Activity 由于被 MessageQueue 持有而无法被回收导致内存泄漏。</p>
<h2 id="卡顿监测的应用"><a href="#卡顿监测的应用" class="headerlink" title="卡顿监测的应用"></a>卡顿监测的应用</h2><p>主线程的所有工作，做种都会回到 MainLooper 中来处理，都会通过 dispatchMessage 来执行，因此如果主线程卡住了，就是在dispatchMessage这里卡住了。<br>上面代码分析中我们也提到了，在 loop 方法中，dispatchMessage 前后都有 Printer 来调用打印Log的接口，因此我们只要在应用程序中为主线程通过 <code>Looper.getMainLooper().setMessageLogging(printer)</code> 设置一个自定义的 Printer，在 Printer 方法中判断start和end，来获取主线程dispatch该message的开始和结束时间，并判定该时间超过阈值(如2000毫秒)为主线程卡慢发生，并dump出各种信息，提供开发者分析性能瓶颈。<br>著名的卡顿监测框架BlockCanary就是用的这个原理。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-消息机制/" rel="tag"># Android 消息机制</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/18/android-graphic-system-glsurfaceview/" rel="next" title="Android 图形系统 -- GLSurfaceView 使用">
                <i class="fa fa-chevron-left"></i> Android 图形系统 -- GLSurfaceView 使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/12/android-knowledge-message-system-idlehandler-sample/" rel="prev" title="Android 消息机制 -- IdleHandler 的用法">
                Android 消息机制 -- IdleHandler 的用法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/icon.png"
               alt="寒江蓑笠" />
          <p class="site-author-name" itemprop="name">寒江蓑笠</p>
          <p class="site-description motion-element" itemprop="description">技术博客</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">219</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">107</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/heqiangflytosky/" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/heqiangflytosky/" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-Handler"><span class="nav-number">2.</span> <span class="nav-text">创建 Handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建消息"><span class="nav-number">3.</span> <span class="nav-text">创建消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发送消息"><span class="nav-number">4.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息队列-MessageQueue"><span class="nav-number">5.</span> <span class="nav-text">消息队列 MessageQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步消息、异步消息和同步栅栏"><span class="nav-number">6.</span> <span class="nav-text">同步消息、异步消息和同步栅栏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息循环-Looper"><span class="nav-number">7.</span> <span class="nav-text">消息循环 Looper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息分发和执行"><span class="nav-number">8.</span> <span class="nav-text">消息分发和执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于内存泄漏"><span class="nav-number">9.</span> <span class="nav-text">关于内存泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#卡顿监测的应用"><span class="nav-number">10.</span> <span class="nav-text">卡顿监测的应用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">寒江蓑笠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "d2475abece3649debc94c21b166fc009",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  






  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("6zbrLyUbhXLbd7RqUSMnxhg4-gzGzoHsz", "fb9g4GyEWQysqnpY9t5CPhpU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
